/**
 * @file selection.h
 *
 *  @date Jan 4, 2011
 *  @author hannes
 *
 *      defines operators based on the (STL-like) BAT-Class
 *      every operator creates a new BAT
 */

#ifndef BAT_SELECTION_H_
#define BATSELECTION_H_

#include "column_operators/BAT_operator.h"

template<class Head, class Tail>
class BAT_selection : public BAT_operator<Head, Tail> {
public:
    typedef typename BAT_operator<Head, Tail>::row_id_t row_id_t;
    typedef typename column<Tail>::iterator iterator;
    typedef typename column<Tail>::const_iterator const_iterator;

private:
    BAT<Head, Tail> input;
    const predicate<Tail>& pred;
    row_id_t input_pos;

public:

    /**
     * Constructor, that will immediately execute the selection
     *
     * @param _input input BAT or column(will be automatically converted to BAT)
     * @param _pred predicate every tail value will be checked for
     * @return
     */
    BAT_selection(const BAT<Head, Tail>& _input, const predicate<Tail>& _pred = pred_true<Tail>())
    : BAT_operator<Head, Tail>(), input(_input), pred(_pred), input_pos(0) {
        execute();
    }

    /**
     * Constructor, used to plan the Selection
     *
     * @param _input input BAT or column(will be automatically converted to BAT)
     * @param _pred predicate every tail value will be checked for
     * @param ex dummy value to distinguish the constructors
     * @return
     */
    BAT_selection(const BAT<Head, Tail>& _input, const predicate<Tail>& _pred, bool ex)
    : BAT_operator<Head, Tail>(), input(_input), pred(_pred), input_pos(0) {
        // no execute();
    }

    virtual bool execute() {
        if (input.head.empty()) {
            row_id_t input_pos = input.first_head;
            for (iterator it = input.tail.begin(); it != input.tail.end(); ++it) {
                if (pred.check(*it)) {
                    this->tail.push_back(*it);
                    this->head.push_back(input_pos);
                }
                ++input_pos;
            }
        } else {
            typename column<row_id_t>::iterator h_it = input.head.begin();

            for (iterator it = input.tail.begin(); it != input.tail.end(); ++it) {
                if (pred.check(*it)) {
                    this->tail.push_back(*it);
                    this->head.push_back(*h_it);
                }
                ++h_it;
            }
        }
        return true;
    }
};

template<class Head, class Tail>
class par_BAT_selection : public par_BAT_operator<Head, Tail> {
public:

    /**
     *
     * @param _input the input column (which already exists by the time, the plan is generated)
     * @param _pred pointer to predicate - object will be deleted, when operator is destroyed
     * @return
     */
    par_BAT_selection(const column<Tail>& _input, predicate<Tail>* _pred) : par_BAT_operator<Head, Tail>(), pred(_pred) {
        unsigned input_pos = 0;
        for (unsigned i = 0; i < _input.partition_count(); ++i) {
            BAT<Head, Tail> part_input_bat(_input.get_partition(i), input_pos);
            BAT_selection<Head, Tail> *sop = new BAT_selection<Head, Tail>(part_input_bat, *_pred, false);

            createTask(sop);
            this->head.push_back_partition(sop->head);
            this->tail.push_back_partition(sop->tail);
            input_pos += part_input_bat.tail.size();
        }
    }

    /**
     *
     * @param _input the BAT generated by a parallel operator (which may already exists or is planned)
     * @param _pred pointer to predicate - object will be deleted, when operator is destroyed
     * @return
     */
    par_BAT_selection(const par_BAT_operator<Head, Tail>& _input, predicate<Tail>* _pred) : par_BAT_operator<Head, Tail>(), pred(_pred) {
        for (unsigned i = 0; i < _input.head.partition_count(); ++i) {
            BAT<Head, Tail> part_input_bat(_input.head.get_partition(i), _input.tail.get_partition(i));
            BAT_selection<Head, Tail> *sop = new BAT_selection<Head, Tail>(part_input_bat, *_pred, false);

            unsigned taskID = createTask(sop);
            this->head.push_back_partition(sop->head);
            this->tail.push_back_partition(sop->tail);
            this->setInput(taskID, _input, sop->taskID);
        }
    }

    ~par_BAT_selection() {
        delete pred;
    }

private:
    predicate<Tail>* pred;
    //vector<column<T> *> input_parts;
    par_BAT_selection(const par_BAT_selection&);
    par_BAT_selection& operator=(const par_BAT_selection&);
};
#endif /* BAT_SELECTION_H_ */
