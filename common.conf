# this config file contains some common settings for the AHEAD benchmarking, used by several scripts

if [[ -z ${AHEAD_COMMON_CONF+x} ]]; then

	######################################################
	# Function to print something and exit.              #
	# Expects the return code as FIRST argument!         #
	######################################################
	AHEAD_exit () {
		ret=$1
		shift
		echo "$@"
		exit $ret
	}
	export -f AHEAD_exit

	######################################################
	# Pretty printing.                                   #
	######################################################
	export AHEAD_SCRIPT_COMMAND_DEPTH=
	export AHEAD_SCRIPT_COMMAND_PREFIX=
	AHEAD_sub_begin () {
		((++AHEAD_SCRIPT_COMMAND_DEPTH))
		local line
		printf -v line '%*s' "$(( AHEAD_SCRIPT_COMMAND_DEPTH * 2 ))"
		export AHEAD_SCRIPT_COMMAND_PREFIX=" ${line// / }* "
		[[ ! -z ${MOREVERBOSE+x} ]] && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Depth=${AHEAD_SCRIPT_COMMAND_DEPTH}. Prefix='${AHEAD_SCRIPT_COMMAND_PREFIX}'"
	}
	export -f AHEAD_sub_begin
	AHEAD_sub_end () {
		((AHEAD_SCRIPT_COMMAND_DEPTH <= 0)) && AHEAD_exit 1 "${AHEAD_SCRIPT_COMMAND_PREFIX}Bash script 'AHEAD_sub_end' called too often!"
		((--AHEAD_SCRIPT_COMMAND_DEPTH))
		local line
		printf -v line '%*s' "$(( AHEAD_SCRIPT_COMMAND_DEPTH * 2 ))"
		export AHEAD_SCRIPT_COMMAND_PREFIX=" ${line// / }* "
		[[ ! -z ${MOREVERBOSE+x} ]] && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Depth=${AHEAD_SCRIPT_COMMAND_DEPTH}. Prefix='${AHEAD_SCRIPT_COMMAND_PREFIX}'"
	}
	export -f AHEAD_sub_end
	AHEAD_sub_reset () {
		((AHEAD_SCRIPT_COMMAND_DEPTH = 0))
		local line
		printf -v line '%*s' "$(( AHEAD_SCRIPT_COMMAND_DEPTH * 2 ))"
		export AHEAD_SCRIPT_COMMAND_PREFIX=" ${line// / }* "
		[[ ! -z ${MOREVERBOSE+x} ]] && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Depth=${AHEAD_SCRIPT_COMMAND_DEPTH}. Prefix='${AHEAD_SCRIPT_COMMAND_PREFIX}'"
	}
	export -f AHEAD_sub_reset
	# "Initialize" pretty printing
	AHEAD_sub_reset

	export AHEAD_COMMON_CONF=""
	SOURCE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null && pwd )"
	echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Sourcing '${SOURCE_DIR}/common.conf'"

	######################################################
	# The following are settings for the modular inverse #
	######################################################
	MI_SCRIPTFILE="modulo_inverse.m"

	######################################################
	# The following are settings for executing AHEAD     #
	######################################################
	AHEAD_sub_begin
	[[ -z ${AHEAD_DATE+x} ]] && export AHEAD_DATE="$(date '+%Y-%m-%d_%H-%M')"
	if which systemd-detect-virt &>/dev/null ; then
		systemd-detect-virt &>/dev/null && export AHEAD_IS_VM=1 || export AHEAD_IS_VM=0
	elif which dmesg &>/dev/null; then
		dmesg | grep -q "Hypervisor detected" && export AHEAD_IS_VM=1 || export AHEAD_IS_VM=0
	else
		# fallback variant -- just assume VM...
		AHEAD_IS_VM=1
	fi
	((AHEAD_IS_VM == 1)) && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}detected VM"
	export AHEAD_PREVIOUS_DATE_FILE="${SOURCE_DIR}/date.prev"
	# Let's simply only enable PCM when not in a virtual machine, because the dependant code will not run therein anyways
	export AHEAD_USE_PCM=$((AHEAD_IS_VM == 1 ? 0 : 1))
	export AHEAD_DB_PATH="${SOURCE_DIR}/database"
	export AHEAD_SCALEFACTOR_PREFIX="sf-"
	export AHEAD_SCALEFACTOR_MIN="1"
	export AHEAD_SCALEFACTOR_MAX="3"

	export AHEAD_BUILD_BASE_DIR="${SOURCE_DIR}/build"
	export AHEAD_BUILD_DEBUG_DIR="${AHEAD_BUILD_BASE_DIR}/Debug"
	export AHEAD_BUILD_RELEASE_DIR="${AHEAD_BUILD_BASE_DIR}/Release"

	export AHEAD_SCALAR_VS_VECTOR_SCALEFACTOR=1
	export AHEAD_SCALAR_VS_VECTOR_QUERIES="(11 12 13)"
	export AHEAD_SCALAR_VS_VECTOR_VARIANT_INDICES="(0 4)"
	export AHEAD_SCALAR_VS_VECTOR_YMIN=0
	export AHEAD_SCALAR_VS_VECTOR_YMAX=3

	export AHEAD_MINBFW_SUFFIX="-minbfw"
	export AHEAD_MINBFW_SCALEFACTOR="1"
	export AHEAD_MINBFW_MIN="1"
	export AHEAD_MINBFW_MAX="3"
	export AHEAD_MINBFW_CMDARG="--AN-minbfw"

	# WARNING: If you want to change the following, make sure to change the respective occurrences throughout this project, e.g. in the CMakeLists.txt files
	export AHEAD_RESTINY32_SUFFIX="_restiny32"

	export AHEAD_PAPER_PATH="${SOURCE_DIR}/paper"
	export AHEAD_PAPER_RESULTS="${AHEAD_PAPER_PATH}/results"
	export AHEAD_PAPER_RESULTS_SSB="${AHEAD_PAPER_RESULTS}/ssb"
	export AHEAD_PAPER_RESULTS_MB="${AHEAD_PAPER_RESULTS}/microbenchmarks"
	export AHEAD_PAPER_RESULTS_MI="${AHEAD_PAPER_RESULTS}/microbenchmarks/ext_euclidean"

	######################################################
	# The following are the names of the scripts to call #
	######################################################
	export AHEAD_SCRIPT_BOOTSTRAP="${SOURCE_DIR}/build_bootstrap.sh"
	export AHEAD_SCRIPT_BLDSRC="${SOURCE_DIR}/build_sources.sh"
	export AHEAD_SCRIPT_GENSSB="${SOURCE_DIR}/generate_ssbdata.sh"
	export AHEAD_SCRIPT_GENSSB_EXECUTABLE="ssbm-dbsize_scalar"
	export AHEAD_SCRIPT_GENSSB_EXECUTABLE_PATH="${AHEAD_BUILD_RELEASE_DIR}/${AHEAD_SCRIPT_GENSSB_EXECUTABLE}"
	export AHEAD_SCRIPT_CODBEN="${SOURCE_DIR}/coding_benchmark.sh"
	export AHEAD_SCRIPT_MODINV="${SOURCE_DIR}/modular_inverse.sh"
	export AHEAD_SCRIPT_TURBOBOOST="${SOURCE_DIR}/turboboost.sh"
	export AHEAD_SCRIPT_GOVERNOR="${SOURCE_DIR}/scalinggovernor.sh"

	######################################################
	# Function to encapsulate pushd verbosity.           #
	######################################################
	AHEAD_pushd () {
		(($# != 1)) && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Error! bash function 'AHEAD_pushd' called with ${#@} arguments, but exactly 1 expected (the pushd target)!" && exit 1
		[[ ! -z ${VERBOSE+x} ]] && { echo -n "${AHEAD_SCRIPT_COMMAND_PREFIX}pushd: "; pushd "$1"; } || pushd "$1" &>/dev/null
	}
	export -f AHEAD_pushd

	######################################################
	# Function to encapsulate popd verbosity.            #
	######################################################
	AHEAD_popd () {
		(($# != 0)) && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Error! bash function 'AHEAD_popd' called with ${#@} arguments, but exactly 0 expected!" && exit 1
		[[ ! -z ${VERBOSE+x} ]] && { echo -n "${AHEAD_SCRIPT_COMMAND_PREFIX}popd: "; popd; } || popd &>/dev/null
	}
	export -f AHEAD_popd

	######################################################
	# When SYNCing file in a VM, we get nasty problems,  #
	# so we add some SLEEPing when inside a VM. This     #
	# fixed the issue for us.                            #
	# All arguments are passed to 'sync'                 #
	######################################################
	AHEAD_sync () {
		if ((AHEAD_IS_VM == 1)); then
			echo -n "${AHEAD_SCRIPT_COMMAND_PREFIX}SYNCing files (VM mode)..." && sleep 2 && sync "$@" && sleep 2 && echo " Done."
		else
			# Unfortunately, it seems that we must force some wait time even in non-VM mode!
			echo -n "${AHEAD_SCRIPT_COMMAND_PREFIX}SYNCing files..." && sleep 1 && sync "$@" && echo " Done."
		fi
	}
	export -f AHEAD_sync

	######################################################
	# Function to capture the output in a temporary file #
	# and print the contents only upon an error.         #
	# The function assumes, that some "echo -n" output   #
	# was previously issued and that we can end the line #
	# with an "echo Error" or "echo Done".               #
	######################################################
	AHEAD_run_hidden_output () {
		(($# == 0)) && echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Error! bash function 'AHEAD_run_hidden_output' called with 0 arguments, but at least 1 expected (the target script or executable)!" && exit 1
		t=$(tempfile) || exit 1
		trap "echo ' Error!'; cat '$t'; rm -f -- '$t'" EXIT
		CMD="$1"
		shift
		"${CMD}" "$@" &>"$t"
		ret=$?
		if ((ret==0)); then
			echo " Done."
		else
			echo ' Error!'
			cat "$t"
		fi
		rm -f -- "$t"
		trap - EXIT
		return $ret
	}
	export -f AHEAD_run_hidden_output

	######################################################
	# The following helper functions calls               #
	# scalinggovernor.sh and turboboost.sh               #
	######################################################
	AHEAD_prepare_scalinggovernor_and_turboboost () {
		if [[ -z ${reproscript+x} ]]; then
			echo "###########################################################"
			echo "# For the following tests, for better reproducibilty, we: #"
			echo "#   * DISABLE turboboost                                  #"
			echo "#   * set the OS scaling governor to PERFORMANCE          #"
			echo "#                                                         #"
			echo "# For that, you need a sudoer account!                    #"
			echo "#                                                         #"
			echo -n "#   * turboboost: "
			sudo "${AHEAD_SCRIPT_TURBOBOOST}" disable &>/dev/null && echo "succeeded.                              #" || echo "failed.                                 #"
			echo -n "#   * scaling governor: "
			modes=($(sudo "${AHEAD_SCRIPT_GOVERNOR}" avail 0))
			hasperformance=0
			for mode in "${modes[@]}"; do
				if [[ "${mode}" == performance ]]; then
					hasperformance=1
					sudo "${AHEAD_SCRIPT_GOVERNOR}" set performance && echo "succeeded.                        #" || echo "failed.                           #"
					break
				fi
			done
			[[ $hasperformance == 0 ]] && echo "failed. Did not find governor.    #"
			echo "###########################################################"
			echo
		fi
	}
	export -f AHEAD_prepare_scalinggovernor_and_turboboost

	AHEAD_sub_end
elif [[ ! -z ${VERBOSE+x} ]]; then
	SOURCE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null && pwd )"
	echo "${AHEAD_SCRIPT_COMMAND_PREFIX}Already sourced '${SOURCE_DIR}/common.conf'!"
fi
